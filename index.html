<script type="module">
import * as THREE from 'three';
import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

// --- SCENE ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x333333);
scene.fog = new THREE.Fog(0x333333, 10, 200);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight,0.1,1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// --- LIGHT ---
const ambientLight = new THREE.AmbientLight(0xffffff,0.5);
scene.add(ambientLight);
const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
dirLight.position.set(10,50,10);
dirLight.castShadow = true;
scene.add(dirLight);

// --- CONTROLS ---
const controls = new PointerLockControls(camera, document.body);
document.getElementById('blocker').addEventListener('click',()=>controls.lock());
controls.addEventListener('lock',()=>{ document.getElementById('blocker').style.display='none'; });
controls.addEventListener('unlock',()=>{ document.getElementById('blocker').style.display='flex'; });
scene.add(controls.getObject());

// --- PLAYER STATE ---
let moveF=false, moveB=false, moveL=false, moveR=false;
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();
let canJump = true;

// --- MAP (floor + walls + props) ---
const floorGeo = new THREE.PlaneGeometry(200,200);
const floorMat = new THREE.MeshStandardMaterial({ color:0x444444 });
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

// walls
const wallMat = new THREE.MeshStandardMaterial({ color:0x222222 });
function makeWall(x,z,w,h){
  const wall = new THREE.Mesh(new THREE.BoxGeometry(w,h,2), wallMat);
  wall.position.set(x,h/2,z);
  wall.castShadow = true;
  wall.receiveShadow = true;
  scene.add(wall);
}
makeWall(0,-100,200,20); // north
makeWall(0,100,200,20);  // south
makeWall(-100,0,2,20);   // west
makeWall(100,0,2,20);    // east

// obstacles
for(let i=0;i<10;i++){
  const box = new THREE.Mesh(new THREE.BoxGeometry(5,5,5), new THREE.MeshStandardMaterial({color:0x666666}));
  box.position.set((Math.random()-0.5)*150,2.5,(Math.random()-0.5)*150);
  box.castShadow = true;
  box.receiveShadow = true;
  scene.add(box);
}

// --- ZOMBIE LOADER ---
const loader = new GLTFLoader();
const zombies = [];
const mixers = [];

// example zombie GLTF (replace with a real model URL!)
loader.load('https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb',(gltf)=>{
  const model = gltf.scene;
  model.scale.set(0.5,0.5,0.5);

  for(let i=0;i<5;i++){
    const zombie = model.clone();
    zombie.position.set((Math.random()-0.5)*100,0,(Math.random()-0.5)*100);
    scene.add(zombie);
    zombies.push(zombie);

    // animation
    const mixer = new THREE.AnimationMixer(zombie);
    const clip = gltf.animations.find(a=>a.name.includes("Walk")) || gltf.animations[0];
    if(clip){
      const action = mixer.clipAction(clip);
      action.play();
    }
    mixers.push(mixer);
  }
});

// --- INPUTS ---
document.addEventListener('keydown',e=>{
  switch(e.code){
    case 'KeyW': moveF=true; break;
    case 'KeyS': moveB=true; break;
    case 'KeyA': moveL=true; break;
    case 'KeyD': moveR=true; break;
    case 'Space': if(canJump){ velocity.y=10; canJump=false; } break;
  }
});
document.addEventListener('keyup',e=>{
  switch(e.code){
    case 'KeyW': moveF=false; break;
    case 'KeyS': moveB=false; break;
    case 'KeyA': moveL=false; break;
    case 'KeyD': moveR=false; break;
  }
});

// --- ANIMATE ---
const clock=new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const delta=clock.getDelta();

  // movement
  direction.z = Number(moveF) - Number(moveB);
  direction.x = Number(moveR) - Number(moveL);
  direction.normalize();
  if(moveF||moveB) velocity.z -= direction.z * 50.0 * delta;
  if(moveL||moveR) velocity.x -= direction.x * 50.0 * delta;

  controls.moveRight(-velocity.x * delta);
  controls.moveForward(-velocity.z * delta);

  velocity.x -= velocity.x * 10.0 * delta;
  velocity.z -= velocity.z * 10.0 * delta;

  // zombie animations
  mixers.forEach(m=>m.update(delta));

  renderer.render(scene,camera);
}
animate();
</script>
